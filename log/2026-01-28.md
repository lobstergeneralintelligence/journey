# 2026-01-28 - LGI-MM Balance Parser Fix

## Session Context
Continuing lgi-mm market maker testing after crash. Testing with CLAWDIA token on Base.

## Problem
Balance parser in `src/bankr/client.ts` couldn't parse Bankr's response format.

**Bankr returns:**
```
ETH - 0.002732388974206735 ($8.30)
Token (0xbbd9aDe16525acb4B336b6dAd3b9762901522B07) - 1260425.075644998881241559 on Base
```

**Old parser expected:** `TOKEN: BALANCE` or `BALANCE TOKEN` formats

## Investigation
1. Ran market maker in dry-run mode
2. Noticed warnings: "Could not parse balance from Bankr response"
3. Checked the Bankr response format by running direct balance queries
4. Identified the pattern: `TOKEN - BALANCE` with optional extras

## Solution
Updated `parseBalance()` function to handle the `- NUMBER` pattern first:

```typescript
// Bankr format: "TOKEN - NUMBER" or "Token (0x...) - NUMBER"
/[-â€“]\s*([0-9,]+\.?[0-9]*)/,
```

## Testing
1. Rebuilt with `npm run build`
2. Ran market maker with $5 position size, live mode
3. **Results:**
   - Price fetched correctly: $7.67e-7
   - Balances parsed: ETH (0.00273), CLAWDIA (1,260,425) âœ…
   - Rebalance logic triggered: sell signal âœ…
   - Trade submitted using CA (not ticker) âœ…
   - Trade execution timed out (Bankr API is slow ~30s per call)

## Commits
- `2d61094` - ðŸ¦ž Fix balance parser for Bankr response format

## Key Learnings
- Always use contract address (CA) when interacting with Bankr, not ticker symbols
- Bankr API calls take ~30 seconds each â€” need to account for this in timeouts
- Test with small amounts ($5) first
- Telegram broadcasts use HTML format, not Markdown

## Config Used
```json
{
  "pair": {
    "base": "CLAWDIA",
    "baseAddress": "0xbbd9aDe16525acb4B336b6dAd3b9762901522B07",
    "quote": "ETH",
    "chain": "base"
  },
  "strategy": {
    "spreadPercent": 5.0,
    "positionSize": 5,
    "rebalanceThreshold": 15
  },
  "dryRun": false
}
```

## Second Test - Extended Timeout (3 min)

### Result: SUCCESS! ðŸŽ‰

**Trade executed:**
- Swapped 0.00032 ETH â†’ 1,260,424 CLAWDIA
- TX: https://basescan.org/tx/0xbfe6c70f2319e1cd001c65645ac24c7f4c5b39abc510df86e8c0b002c2e7d97e

**New parser bug found:**
Bankr returned: `"you currently have 0 of the token 0xbbd9..."`
Parser didn't handle conversational format â†’ thought balance was 0 â†’ triggered buy

**Fix applied:**
Added patterns for `"you currently have X"` and `"you hold X"` formats

**Commits:**
- `81f224e` - ðŸ¦ž Fix parser for 'you currently have X' format

### Post-Trade Balances
- ETH: 0.00272 (~$8.27)
- CLAWDIA: 1,260,424 tokens

## Accumulate Mode Implementation

### Design
Two operating modes designed:
1. **Liquidity** - For token project owners (support price, rebalance)
2. **Accumulate** - For DCA/stacking (time-based buys + dip buying)

### Implementation (accumulate mode)
Created `src/core/accumulate.ts` with:
- Time-based DCA buys (configurable interval)
- Dip detection from recent high
- Optional take-profit on pumps
- Max accumulation limit

### Key Decisions
1. **Use DexScreener for price** - Fast, avoids Bankr API flagging tokens
2. **Only fetch quote (ETH) balance from Bankr** - Minimizes API calls
3. **Track token balance in state** - Avoids querying flagged token
4. **Hardcoded ETH price ($3000)** - TODO: fetch real price

### Bug Fixes During Implementation
- Fixed balance check: was comparing ETH amount to USD, now converts properly
- Fixed Bankr response parsing for "you currently have X" format

### Test Results
```
Price fetch: instant (DexScreener)
Balance: 0.00272 ETH (~$8.17 USD)
[DRY RUN] Would BUY $2 of CLAWDIA (DCA) âœ…
```

### Commits
- `45a05b2` - ðŸ¦ž Add MODES.md - design doc
- `f9b0d77` - ðŸ¦ž Implement accumulate mode

## Manual Buy/Sell Test

Testing Bankr trading flow directly before relying on it in automated mode.

### BUY Test
```
Prompt: "Buy $1 worth of 0xbbd9aDe16525acb4B336b6dAd3b9762901522B07 on Base"
Result: Swapped 0.000324 ETH â†’ 1,277,765 CLAWDIA
TX: https://basescan.org/tx/0x7088c8a9496fe9c85b50db92583ec62cf83e71799dd5d4cef1351e70a1fcec42
```

### SELL Test
```
Prompt: "Sell all of my 0xbbd9aDe16525acb4B336b6dAd3b9762901522B07 tokens on Base"
Result: Swapped 2,538,190 CLAWDIA â†’ 0.000624 ETH
TX: https://basescan.org/tx/0xc205a1472d4992490ad22b27aec1924fe937240ec749b71d1de4eb0e327ae7e5
```

**Note:** Sold more than bought because had existing balance from earlier tests.

### Conclusion
âœ… Buy works
âœ… Sell works
âœ… Bankr handles CA correctly
âœ… Ready for automated mode testing

## Persistence Layer Implementation

### Design
Created comprehensive design doc in `docs/PERSISTENCE.md`:
- Job lifecycle: IDLE â†’ RUNNING â†’ PAUSED â†’ LIQUIDATING â†’ IDLE
- Per-token jobs with full state tracking
- Trade history for analytics

### Implementation
Added Postgres + Prisma:
- `docker-compose.example.yml` - DB template (gitignored: docker-compose.yml)
- `prisma/schema.prisma` - Job + Trade models
- `src/db/client.ts` - Connection singleton
- `src/db/jobs.ts` - CRUD + state updates

### Key Functions
```typescript
createJob(tokenAddress, mode, config)
updateJobStatus(jobId, status)
updateAccumulateState(jobId, { lastDcaBuyTime, recentHigh, ... })
recordTradeWithStateUpdate(jobId, trade, stateUpdate)  // atomic
resetJob(jobId)  // after liquidation
```

### Commits
- `b49c7e4` - Persistence design doc
- `8e2d4b9` - Postgres + Prisma implementation

### Note
Docker not installed on this server. Options:
1. Install Docker
2. Use external Postgres (Supabase, Railway)
3. Run locally

## Database Integration Testing

### Test 1: New Job Creation
```
âœ… Database connected
âœ… Created new job: 861d9a92-f95f-4eb7-b3f1-0a398859be04
âœ… Set status to RUNNING
âœ… Ran tick, DCA triggered (dry run)
âœ… State saved: recentHigh, lastDcaBuyTime
```

### Test 2: Job Resume
```
âœ… Found existing job
âœ… Loaded state from DB
âœ… lastDcaBuyTime remembered â†’ skipped DCA (not time yet)
âœ… recentHigh loaded correctly
```

### Commits
- `315f6eb` - Initial migration
- `70c808c` - Engine integration

### Verified Working
- Job creation and retrieval
- State persistence (recentHigh, lastDcaBuyTime, tokenBalance)
- Resume after crash/restart
- DCA timing respected across restarts

## Next Steps
- Run live (non-dry-run) test
- Implement liquidate command
- Implement liquidity mode
- Get real ETH price instead of hardcoded

## Live Accumulate Test

### Configuration
```json
{
  "mode": "accumulate",
  "dryRun": false,
  "dcaAmount": 1,
  "dcaIntervalHours": 0.0167,  // ~60 seconds
  "maxAccumulationUsd": 5
}
```

### Results
Executed 4 successful trades before process timeout:
- Trade 1: 0.000325 ETH â†’ 1,165,474 CLAWDIA
  - TX: 0xef0617143700d46b71c490f082c49ee34ba26b1ef22c40f08dc11027db2d8b14
- Trade 2: 0.000325 ETH â†’ 1,165,429 CLAWDIA
  - TX: 0x0b65f3f1affe8fc893c0a77f6ae115c9b34ec2ab90289df1b4f9b5e26cfef264
- Trade 3: 0.000325 ETH â†’ 1,165,384 CLAWDIA
  - TX: 0x67bce24b661c961bf91f51d2f5126b13fd0fee242e87fbf800a0ad0d1941eda6
- Trade 4: 0.000325 ETH â†’ 1,165,339 CLAWDIA
  - TX: 0xb57787ecf4c250fbea2af4470490de65d0d82b10a2f435a6fd11e7f078d19500

5th trade was executing when session timed out (Bankr API is slow).

### Issues Discovered

1. **Concurrent tick execution** - Bankr API takes ~30s per call. With 30s tick interval, ticks overlap.
2. **TX hash not saved** - Wasn't parsing TX hash from Bankr response
3. **Token amount not saved** - Wasn't parsing actual tokens received from swap

### Fixes Applied

#### Fix #1: TX Hash and Token Amount Parsing (bb25e4d)
- Added `parseTxHash()` - extracts TX hash from basescan URLs
- Added `parseSwapAmount()` - extracts actual tokens received
- Updated buy/sell functions to use new parsers

#### Fix #2: Trade Lock (f639daf)
- Added `tickLock` flag to accumulate engine
- Ticks skip if previous tick still running
- Prevents duplicate trades from overlapping API calls

### Validation Schema Relaxed (for testing)
- `dcaIntervalHours` min: 0.5 â†’ 0.01 (~36 seconds)
- `maxAccumulationUsd` min: 10 â†’ 1

### Commits
- `bb25e4d` - Fix TX hash and token amount parsing
- `f639daf` - Add trade lock to prevent concurrent execution

### Lessons Learned
1. Bankr API is slow (~30s per call) - need longer tick intervals or async execution
2. Always test parsing with real API responses, not assumptions
3. Concurrent execution is a real problem with slow APIs
4. Trade locks are essential for rate-limited external APIs
